# feature_engineering_installments.py
import pandas as pd
import numpy as np
import gc # Import garbage collector
from scipy import stats  # Import scipy.stats for skewness and kurtosis functions

def engineer_installments_features(X, installments_payments):
    """
    Engineers features from the installments_payments DataFrame, joining them to X.

    Args:
        X (pd.DataFrame): The main application DataFrame.
        installments_payments (pd.DataFrame): The installments_payments DataFrame.

    Returns:
        pd.DataFrame: DataFrame X with engineered installments features added.
    """
    print("\n--- Engineering Installments Features (Notebook Alignment) ---")
    if installments_payments is None or installments_payments.empty:
        print("DEBUG: Input installments_payments DataFrame is empty or None. Skipping Installments features.")
        # Add placeholder columns expected by later stages if they don't exist
        # This part might need adjustment based on exactly which columns are essential later
        expected_cols = [ # Add expected column names generated by this function if needed
            # Example: 'DAYS_PAST_DUE_MEAN_(INSTALL_PAY)', 'COUNT_INSTALLMENTS_PAID_(INSTALL_PAY)', etc.
        ]
        for col in expected_cols:
             if col not in X.columns:
                 X[col] = np.nan 
        return X

    install_pay_to_agg = installments_payments.copy()

    # Calculate payment difference and days past due/paid early (aligning names and logic)
    # Add epsilon to prevent division by zero
    install_pay_to_agg['PCTG_PAYMENT'] = install_pay_to_agg['AMT_PAYMENT'] / (install_pay_to_agg['AMT_INSTALMENT'] + 1e-8) 
    install_pay_to_agg['DIFF_PAYMENT'] = install_pay_to_agg['AMT_INSTALMENT'] - install_pay_to_agg['AMT_PAYMENT']

    # Days past due and days before due (define DPD and DBD - align names)
    install_pay_to_agg['DAYS_PAST_DUE'] = install_pay_to_agg['DAYS_ENTRY_PAYMENT'] - install_pay_to_agg['DAYS_INSTALMENT']
    install_pay_to_agg['DAYS_BEFORE_DUE'] = install_pay_to_agg['DAYS_INSTALMENT'] - install_pay_to_agg['DAYS_ENTRY_PAYMENT']
    # Use np.maximum for non-negativity (equivalent to notebook's lambda)
    install_pay_to_agg['DAYS_PAST_DUE'] = np.maximum(install_pay_to_agg['DAYS_PAST_DUE'], 0)
    install_pay_to_agg['DAYS_BEFORE_DUE'] = np.maximum(install_pay_to_agg['DAYS_BEFORE_DUE'], 0)

    # ----- Numerical Aggregations (Notebook Dictionary) -----
    aggregations = {
        'NUM_INSTALMENT_VERSION': ['max', 'nunique'], # Changed from script's ['nunique']
        'DAYS_PAST_DUE': ['max', 'mean', 'sum'], # Changed from script's ['max', 'mean', 'sum', 'min', 'std']
        'DAYS_BEFORE_DUE': ['max', 'mean', 'sum'], # Changed from script's ['max', 'mean', 'sum', 'min', 'std']
        'DAYS_INSTALMENT': ['min'], # New aggregation from notebook
        'PCTG_PAYMENT': ['min', 'max', 'mean', 'sum', 'var'], # Renamed from PAYMENT_PERC, added 'var'
        'DIFF_PAYMENT': ['max', 'mean', 'sum', 'var'], # Renamed from PAYMENT_DIFF, added 'var', removed 'min', 'std'
        'AMT_INSTALMENT': ['max', 'mean', 'sum'], # Removed 'min', 'std'
        'AMT_PAYMENT': ['min', 'max', 'mean', 'sum'], # Removed 'std'
        'DAYS_ENTRY_PAYMENT': ['min', 'max', 'mean', 'sum'] # Removed 'std'
    }

    # Aggregate features per SK_ID_CURR
    install_agg_df = install_pay_to_agg.groupby('SK_ID_CURR').agg(aggregations)
    # Update column naming
    install_agg_df.columns = pd.Index([f'{e[0]}_{e[1].upper()}_(INSTALL_PAY)' for e in install_agg_df.columns.tolist()])
    
    # Join aggregated features to main DataFrame X
    X = X.join(install_agg_df, on='SK_ID_CURR', how='left' )
    print(f"DEBUG: Shape after joining install aggregations: {X.shape}")
    
    # 'COUNT_INSTALLMENTS_PAID_(INSTALL_PAY)': Total number of installments (Notebook method)
    count_installments_df = installments_payments[['SK_ID_CURR', 'NUM_INSTALMENT_NUMBER']].groupby(['SK_ID_CURR'], as_index=False, sort=False).count()
    count_installments_df = count_installments_df.rename(index=str, columns = {'NUM_INSTALMENT_NUMBER': 'COUNT_INSTALLMENTS_PAID_(INSTALL_PAY)'})
    # Join to main dataframe
    X = X.join(count_installments_df.set_index('SK_ID_CURR'), on='SK_ID_CURR', how='left')
    print(f"DEBUG: Shape after joining paid count: {X.shape}")
    del count_installments_df
    gc.collect()

    # 'COUNT_INSTALLMENTS_ACCTS_CAT_(INSTALL_PAY)': Number of installment accounts (Notebook method)
    count_install_accts_df = installments_payments[['SK_ID_CURR', 'SK_ID_PREV']]
    count_install_accts_df = pd.DataFrame(data=count_install_accts_df.groupby(['SK_ID_CURR'], as_index=True)['SK_ID_PREV'].nunique()).reset_index(level=0, inplace=False)
    count_install_accts_df = count_install_accts_df.rename(index=str, columns = {'SK_ID_PREV': 'COUNT_INSTALLMENTS_ACCTS_CAT_(INSTALL_PAY)'})
    # Convert to category type as per notebook
    count_install_accts_df['COUNT_INSTALLMENTS_ACCTS_CAT_(INSTALL_PAY)'] = count_install_accts_df['COUNT_INSTALLMENTS_ACCTS_CAT_(INSTALL_PAY)'].astype('category')
    # Join to main dataframe
    X = X.join(count_install_accts_df.set_index('SK_ID_CURR'), on='SK_ID_CURR', how='left')
    print(f"DEBUG: Shape after joining account count: {X.shape}")
    del count_install_accts_df
    gc.collect()

    # 'INSTALMENT_VERSION_LAST_DUE_CAT_(INSTALL_PAY)': Installment version of last due (Notebook method)
    last_version_df = installments_payments[['SK_ID_CURR', 'DAYS_INSTALMENT', 'NUM_INSTALMENT_VERSION']]
    # Sort and get the last record per SK_ID_CURR based on DAYS_INSTALMENT
    last_version_df = last_version_df.loc[last_version_df.sort_values(['SK_ID_CURR','DAYS_INSTALMENT']).drop_duplicates('SK_ID_CURR',keep='last').index]
    last_version_df = last_version_df.rename(index=str, columns = {'NUM_INSTALMENT_VERSION': 'INSTALMENT_VERSION_LAST_DUE_CAT_(INSTALL_PAY)'})
    # Convert to category type as per notebook
    last_version_df['INSTALMENT_VERSION_LAST_DUE_CAT_(INSTALL_PAY)'] = last_version_df['INSTALMENT_VERSION_LAST_DUE_CAT_(INSTALL_PAY)'].astype('category')
    # Join to main dataframe
    X = X.join(last_version_df[['SK_ID_CURR', 'INSTALMENT_VERSION_LAST_DUE_CAT_(INSTALL_PAY)']].set_index('SK_ID_CURR'), on='SK_ID_CURR', how='left')
    print(f"DEBUG: Shape after joining last version: {X.shape}")
    del last_version_df
    gc.collect()

    # Remove fillna(0) - rely on left joins
    # print(f"DEBUG: Filling NaNs in {installments_agg.shape[1]} INSTALL_ columns before return.")
    # installments_agg = installments_agg.fillna(0)
    
    # Calculate skewness and kurtosis features
    print("Calculating skewness and kurtosis features for installments...")
    # Define custom functions for skewness and kurtosis
    def safe_skew(x):
        if len(x) > 2:  # Need at least 3 values for skewness
            return stats.skew(x, nan_policy='omit')
        return np.nan
        
    def safe_kurt(x):
        if len(x) > 3:  # Need at least 4 values for kurtosis
            return stats.kurtosis(x, nan_policy='omit')
        return np.nan
        
    skew_kurt_features = installments_payments.groupby('SK_ID_CURR').agg({
        'AMT_PAYMENT': [safe_skew, safe_kurt],
        'AMT_INSTALMENT': [safe_skew, safe_kurt],
        'DAYS_ENTRY_PAYMENT': [safe_skew, safe_kurt]
    })
    
    # Rename columns
    skew_kurt_features.columns = ['_'.join(col).upper() + '_(INSTALL_PAY)' for col in skew_kurt_features.columns.ravel()]
    X = X.join(skew_kurt_features, on='SK_ID_CURR', how='left')
    print(f"DEBUG: Shape after joining skewness and kurtosis features: {X.shape}")
    del skew_kurt_features
    gc.collect()
    
    # Calculate coefficient of variation (CV) features
    print("Calculating coefficient of variation features for installments...")
    # Create a function to calculate CV safely
    def safe_cv(x):
        mean = x.mean()
        std = x.std()
        if abs(mean) < 1e-10 or pd.isna(mean) or pd.isna(std):
            return np.nan
        return std / mean
    
    # Calculate payment amount CV
    cv_features = installments_payments.groupby('SK_ID_CURR')['AMT_PAYMENT'].apply(safe_cv)
    cv_features = cv_features.to_frame('PAYMENT_AMOUNT_CV_(INSTALL_PAY)')
    
    # Calculate payment ratio CV
    installments_payments['PAYMENT_RATIO'] = installments_payments['AMT_PAYMENT'] / (installments_payments['AMT_INSTALMENT'] + 1e-10)
    cv_ratio = installments_payments.groupby('SK_ID_CURR')['PAYMENT_RATIO'].apply(safe_cv)
    cv_ratio = cv_ratio.to_frame('PAYMENT_RATIO_CV_(INSTALL_PAY)')
    
    cv_features = cv_features.join(cv_ratio)
    X = X.join(cv_features, on='SK_ID_CURR', how='left')
    print(f"DEBUG: Shape after joining coefficient of variation features: {X.shape}")
    del cv_features, cv_ratio
    gc.collect()

    del install_pay_to_agg # Clean up the initial dataframe copy
    gc.collect()

    print("Installments features engineered (Notebook alignment).")
    return X # Return the modified main DataFrame
